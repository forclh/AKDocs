# âœ¨ æ‡’åŠ è½½ ğŸ‘Œ

### IntersectionObserver

`IntersectionObserver` æ˜¯ä¸€ä¸ª**ç°ä»£æµè§ˆå™¨ API**ï¼Œç”¨äº**æ£€æµ‹ä¸€ä¸ªå…ƒç´ ï¼ˆæˆ–å…¶å­å…ƒç´ ï¼‰ç›¸å¯¹äºè§†å£æˆ–æŸä¸ªç¥–å…ˆå…ƒç´ çš„å¯è§æ€§å˜åŒ–**ã€‚

**åŸºæœ¬ç”¨æ³•**

```js
const ob = new IntersectionObserver(callback, options);
```

1. `callback`: **å½“è¢«è§‚å¯Ÿå…ƒç´ çš„å¯è§æ€§å˜åŒ–æ—¶è°ƒç”¨çš„å›è°ƒå‡½æ•°**ï¼Œ`callback` **ä¸€å¼€å§‹ä¼šè§¦å‘ä¸€æ¬¡ï¼Œç¡®è®¤å½“å‰çš„å¯è§†çŠ¶æ€**ï¼ˆæ— è®ºå½“å‰æ˜¯å¯è§è¿˜æ˜¯ä¸å¯è§ï¼‰ï¼Œä¹‹ååœ¨æ¯æ¬¡å¯è§†çŠ¶æ€å‘ç”Ÿæ”¹å˜æ—¶ä¼šè§¦å‘ã€‚å›è°ƒå‡½æ•°é‡Œé¢æœ‰ä¸¤ä¸ªå‚æ•°ï¼š

    - `entries`: ä¸€ä¸ªæ•°ç»„ï¼ŒåŒ…å«æ‰€æœ‰è¢«è§‚å¯Ÿå…ƒç´ çš„ `IntersectionObserverEntry` å¯¹è±¡ï¼Œæ¯ä¸ªå¯¹è±¡åŒ…å«ä»¥ä¸‹å±æ€§ï¼š
        - `boundingClientRect`: è¢«è§‚å¯Ÿå…ƒç´ çš„çŸ©å½¢åŒºåŸŸä¿¡æ¯ã€‚
        - `intersectionRatio`: è¢«è§‚å¯Ÿå…ƒç´ çš„å¯è§éƒ¨åˆ†ä¸æ•´ä¸ªå…ƒç´ çš„æ¯”ä¾‹ã€‚
        - `intersectionRect`: å¯è§éƒ¨åˆ†çš„çŸ©å½¢åŒºåŸŸä¿¡æ¯ã€‚
        - `isIntersecting`: å¸ƒå°”å€¼ï¼Œ**è¡¨ç¤ºå…ƒç´ æ˜¯å¦ä¸æ ¹å…ƒç´ ç›¸äº¤**ã€‚
        - `rootBounds`: æ ¹å…ƒç´ çš„çŸ©å½¢åŒºåŸŸä¿¡æ¯ã€‚
        - `target`: è¢«**è§‚å¯Ÿçš„ç›®æ ‡å…ƒç´ **ã€‚
        - `time`: è§¦å‘å›è°ƒçš„æ—¶é—´æˆ³ã€‚
    - `observer`: `IntersectionObserver` å®ä¾‹æœ¬èº«ã€‚

2. `options`: é…ç½®å¯¹è±¡ï¼Œç”¨äº**å®šåˆ¶è§‚å¯Ÿè¡Œä¸º**

    - `root`ï¼š**æŒ‡å®šç”¨ä½œè§†å£çš„å…ƒç´ ï¼Œé»˜è®¤å€¼ä¸º nullï¼Œè¡¨ç¤ºä½¿ç”¨æµè§ˆå™¨è§†å£ä½œä¸ºæ ¹å…ƒç´ ã€‚**

    - `rootMargin`: ç±»ä¼¼äº CSS çš„ margin å±æ€§ï¼Œ**å®šä¹‰æ ¹å…ƒç´ çš„å¤–è¾¹è·ï¼Œç”¨äºæ‰©å±•æˆ–ç¼©å°æ ¹å…ƒç´ çš„åˆ¤å®šåŒºåŸŸã€‚**å¯ä»¥ç”¨åƒç´ æˆ–ç™¾åˆ†æ¯”è¡¨ç¤ºï¼Œä¾‹å¦‚ '10px' æˆ– '10%'ã€‚
    - `threshold`: æ˜¯ä¸€ä¸ª 0 ï½ 1 ä¹‹é—´çš„å€¼ï¼Œè¡¨ç¤ºä¸€ä¸ªè§¦å‘çš„é˜ˆå€¼ï¼Œå¦‚æœæ˜¯ 0ï¼Œåªè¦ç›®æ ‡å…ƒç´ ä¸€ç¢°åˆ° root å…ƒç´ ï¼Œå°±ä¼šè§¦å‘ï¼Œå¦‚æœæ˜¯ 1ï¼Œè¡¨ç¤ºç›®æ ‡å…ƒç´ å®Œå…¨è¿›å…¥ root å…ƒç´ èŒƒå›´ï¼Œæ‰ä¼šè§¦å‘ã€‚**è®¾ç½®è§‚å¯Ÿå…ƒç´ è¿›å…¥åˆ°æ ¹å…ƒç´ çš„ç™¾åˆ†æ¯”ã€‚**

æœ‰äº† observer å®ä¾‹å¯¹è±¡åï¼Œè¦è§‚å¯Ÿå“ªä¸ªå…ƒç´ ï¼Œç›´æ¥é€šè¿‡ `observe` æ–¹æ³•æ¥è¿›è¡Œè§‚å¯Ÿå³å¯ï¼Œå–æ¶ˆè§‚å¯Ÿé€šè¿‡ `unobserve` æ–¹æ³•ï¼š

```js
// å¼€å§‹è§‚å¯Ÿ
ob.observe(elementA);
ob.observe(elementB);

// åœæ­¢è§‚å¯Ÿ
ob.unobserve(element);
```

**ç¤ºä¾‹ 1**

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Document</title>
        <style>
            body {
                height: 2000px; /*ä¾¿äºå‡ºç°æ»šåŠ¨æ¡*/
                margin: 0;
                padding: 0;
            }

            .target {
                width: 200px;
                height: 200px;
                background-color: #e81b3a;
                margin: 0 auto;
                margin-top: 1500px;
            }
        </style>
    </head>
    <body>
        <div class="target"></div>
        <script>
            // è·å–è¢«è§‚å¯Ÿçš„å…ƒç´ 
            const target = document.querySelector(".target");

            // å½“è¢«è§‚å¯Ÿçš„å…ƒç´ å¯è§æ€§å‘ç”Ÿå˜åŒ–çš„æ—¶å€™ä¼šè°ƒç”¨è¿™ä¸ªå‡½æ•°
            function callback(entries) {
                // æ£€æŸ¥ç›®æ ‡å…ƒç´ æ˜¯å¦è¿›å…¥è§†å£
                entries.forEach((element) => {
                    if (element.isIntersecting) {
                        console.log("è¿›å…¥è§†å£");
                    } else {
                        console.log("ç¦»å¼€è§†å£");
                    }
                });
            }

            // åˆ›å»ºè§‚å¯Ÿå™¨
            const ob = new IntersectionObserver(callback, {
                root: null, // å°†æµè§ˆå™¨è§†å£ä½œä¸ºæ ¹å…ƒç´ 
                rootMargin: "0px", // æ ¹å…ƒç´ çš„å¤–è¾¹è·
                threshold: 0, // ç›®æ ‡å…ƒç´ è¿›å…¥åˆ°æ ¹å…ƒç´ çš„ç™¾åˆ†æ¯”
            });

            // è§‚å¯Ÿç›®æ ‡å…ƒç´ 
            ob.observe(target);
        </script>
    </body>
</html>
```

**ç¤ºä¾‹ 2**

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Document</title>
        <style>
            .container {
                width: 100%;
                height: 500px;
                border: 1px solid black;
                overflow: scroll;
            }

            .target {
                width: 200px;
                height: 200px;
                background-color: lightcoral;
                margin: 0 auto;
                margin-top: 1000px;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="target"></div>
        </div>
        <script>
            // è·å–è¢«è§‚å¯Ÿçš„å…ƒç´ 
            const target = document.querySelector(".target");

            // å½“è¢«è§‚å¯Ÿçš„å…ƒç´ å¯è§æ€§å‘ç”Ÿå˜åŒ–çš„æ—¶å€™ä¼šè°ƒç”¨è¿™ä¸ªå‡½æ•°
            function callback(entries) {
                // æ£€æŸ¥ç›®æ ‡å…ƒç´ æ˜¯å¦è¿›å…¥è§†å£
                entries.forEach((element) => {
                    if (element.isIntersecting) {
                        console.log("è¿›å…¥è§†å£");
                    } else {
                        console.log("ç¦»å¼€è§†å£");
                    }
                });
            }

            // åˆ›å»ºè§‚å¯Ÿå™¨
            const ob = new IntersectionObserver(callback, {
                root: document.querySelector(".container"), // å°† container ä½œä¸ºæ ¹å…ƒç´ 
                rootMargin: "-50px", // æ ¹å…ƒç´ çš„å¤–è¾¹è·ï¼ˆè´Ÿæ•°è¡¨ç¤ºå‘å†…æ”¶ç¼©ï¼‰
                threshold: 0, // ç›®æ ‡å…ƒç´ è¿›å…¥åˆ°æ ¹å…ƒç´ çš„ç™¾åˆ†æ¯”
            });

            // è§‚å¯Ÿç›®æ ‡å…ƒç´ 
            ob.observe(target);
        </script>
    </body>
</html>
```

### æ‡’åŠ è½½

**æ‡’åŠ è½½å«ä¹‰ï¼šå½“å‡ºç°çš„æ—¶å€™å†åŠ è½½ã€‚**

**æ‡’åŠ è½½æ ¸å¿ƒåŸç†ï¼šimg å…ƒç´ åœ¨ src å±æ€§æœ‰å€¼æ—¶ï¼Œæ‰ä¼šå»è¯·æ±‚å¯¹åº”çš„å›¾ç‰‡åœ°å€**ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥å…ˆç»™å›¾ç‰‡ä¸€å¼ é»˜è®¤çš„å ä½å›¾ï¼š

```html
<img src="å ä½å›¾.png" />
```

å†è®¾ç½®ä¸€ä¸ª**è‡ªå®šä¹‰å±æ€§ data-src**ï¼Œå¯¹åº”çš„å€¼ä¸ºçœŸå®çš„å›¾ç‰‡åœ°å€ï¼š

```html
<img src="å ä½å›¾.png" data-src="å›¾ç‰‡çœŸå®åœ°å€" />
```

ä¹‹å**åˆ¤æ–­å½“ç„¶è¿™ä¸ª img å…ƒç´ æœ‰æ²¡æœ‰è¿›å…¥å¯è§†åŒºåŸŸ**ï¼Œå¦‚æœè¿›å…¥äº†ï¼Œå°±æŠŠ data-src çš„å€¼èµ‹ç»™ srcï¼Œè®©çœŸå®çš„å›¾ç‰‡æ˜¾ç¤ºå‡ºæ¥ã€‚è¿™å°±æ˜¯å›¾ç‰‡æ‡’åŠ è½½çš„åŸºæœ¬åŸç†ã€‚

ä¸è¿‡è¿™é‡Œå¯¹äºåˆ¤æ–­ img å…ƒç´ æœ‰æ²¡æœ‰è¿›å…¥å¯è§†åŒºåŸŸï¼Œæœ‰ç€æ–°æ—§ä¸¤å¥—æ–¹æ¡ˆã€‚

#### æ—§æ–¹æ¡ˆ

æ—©æœŸçš„æ–¹æ¡ˆæ˜¯ç›‘å¬é¡µé¢çš„æ»šåŠ¨ï¼š

```js
window.addEventListener("scroll", () => {});
```

å½“ img æ ‡ç­¾çš„é¡¶éƒ¨åˆ°å¯è§†åŒºåŸŸé¡¶éƒ¨çš„è·ç¦»ï¼Œå°äºå¯è§†åŒºåŸŸé«˜åº¦çš„æ—¶å€™ï¼Œæˆ‘ä»¬å°±è®¤ä¸ºå›¾ç‰‡è¿›å…¥äº†å¯è§†åŒºåŸŸï¼Œç”»å¼ å›¾è¡¨ç¤ºï¼š

<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2024-07-24-074243.png" alt="image-20240724154242876" style="zoom:50%;" />

ç¤ºä¾‹ä»£ç ï¼š

```js
window.addEventListener("scroll", () => {
    const img = document.querySelectorAll("img");
    img.forEach((img) => {
        const rect = img.getBoundingClientRect();
        if (rect.top < document.body.clientHeight) {
            // å½“å‰è¿™å¼ å›¾ç‰‡è¿›å…¥åˆ°å¯è§†åŒºåŸŸ
            // åš src çš„æ›¿æ¢
            img.src = img.dataset.src;
        }
    });
});
```

ç¼ºç‚¹ï¼š

-   _scroll_ äº‹ä»¶é¢‘ç¹è§¦å‘
-   éœ€è¦æ‰‹åŠ¨è®¡ç®—ç›®æ ‡å…ƒç´ æ˜¯å¦è¿›å…¥å¯æ˜¯åŒºåŸŸ

#### æ–°æ–¹æ¡ˆ

ä½¿ç”¨ IntersectionObserver æ¥å®ç°ã€‚

```js
let observer = new IntersectionObserver(
    (entries, observer) => {
        for (const entrie of entries) {
            if (entrie.isIntersecting) {
                // è¿›å…¥æ­¤åˆ†æ”¯ï¼Œè¯´æ˜å½“å‰çš„å›¾ç‰‡å’Œæ ¹å…ƒç´ äº§ç”Ÿäº†äº¤å‰
                const img = entrie.target; // æ‹¿åˆ°è§‚å¯Ÿçš„ç›®æ ‡å…ƒç´ 
                img.src = img.dataset.src; // å±æ€§æ›¿æ¢
                observer.unobserve(img);
            }
        }
    },
    {
        root: null,
        rootMargin: "0px 0px 0px 0px",
        threshold: 0.5,
    }
);
// å…ˆæ‹¿åˆ°æ‰€æœ‰çš„å›¾ç‰‡å…ƒç´ 
const imgs = document.querySelectorAll("img");
imgs.forEach((img) => {
    //è§‚å¯Ÿæ‰€æœ‰çš„å›¾ç‰‡å…ƒç´ 
    observer.observe(img);
});
```

ä¸æ—§æ–¹æ¡ˆç›¸æ¯”æ€§èƒ½æ›´é«˜ï¼Œåªæœ‰åœ¨ç›®æ ‡å…ƒç´ å’Œæ ¹å…ƒç´ å‘ç”Ÿäº¤å‰çš„æ—¶å€™æ‰ä¼šè§¦å‘å›è°ƒã€‚

#### ç»“åˆä¸¤ç§æ–¹æ¡ˆ

```js
// ä¼˜åŒ–åçš„æ‡’åŠ è½½æ–¹æ¡ˆ
document.addEventListener("DOMContentLoaded", () => {
    const lazyImages = Array.from(document.querySelectorAll("img[data-src]"));
    if (!lazyImages.length) return;

    // æ–¹æ¡ˆ1ï¼šä¼˜å…ˆä½¿ç”¨ IntersectionObserverï¼ˆç°ä»£æµè§ˆå™¨ï¼‰
    if ("IntersectionObserver" in window) {
        const observer = new IntersectionObserver(
            (entries, observer) => {
                entries.forEach((entry) => {
                    if (entry.isIntersecting) {
                        const img = entry.target;
                        img.src = img.dataset.src;
                        img.onload = () => img.removeAttribute("data-src");
                        observer.unobserve(img);
                    }
                });
            },
            {
                rootMargin: "0px 0px 100px 0px", // æå‰100pxåŠ è½½
            }
        );

        lazyImages.forEach((img) => observer.observe(img));
    }
    // æ–¹æ¡ˆ2ï¼šå…¼å®¹æ—§æµè§ˆå™¨çš„æ»šåŠ¨æ–¹æ¡ˆ
    else {
        let active = false; // æ ‡è®°æ˜¯å¦å‡½æ•°æ­£åœ¨è¿è¡Œ
        const lazyLoad = () => {
            if (active) return;
            active = true;

            setTimeout(() => {
                lazyImages.forEach((img) => {
                    const rect = img.getBoundingClientRect();
                    if (rect.top <= window.innerHeight + 100) {
                        // +100pxç¼“å†²
                        img.src = img.dataset.src;
                        img.onload = () => img.removeAttribute("data-src");
                        let index = lazyImages.indexOf(img);
                        if (index !== -1) {
                            lazyImages.splice(index, 1); // å»é™¤åŠ è½½å®Œæˆçš„å›¾ç‰‡
                        }
                    }
                });
                active = false;
            }, 200);
        };

        // åˆå§‹åŒ–åŠ è½½å¯è§†åŒºå›¾ç‰‡
        lazyLoad();

        // æ»šåŠ¨äº‹ä»¶ç›‘å¬ï¼ˆå¸¦èŠ‚æµï¼‰
        window.addEventListener("scroll", lazyLoad);
        window.addEventListener("resize", lazyLoad);
    }
});
```

[åœ¨çº¿æ¼”ç¤º](https://codepen.io/forclh/pen/VYLNKXX)

## Vue ç›¸å…³åº“

åœ¨ Vue ä¸­ [vue3-observe-visibility](https://www.npmjs.com/package/vue3-observe-visibility/v/1.0.3) åº“å¯¹ IntersectionObserver API è¿›è¡Œäº†è¿›ä¸€æ­¥å°è£…å®ç°çš„

å®‰è£…ï¼š

```bash
npm install --save vue3-observe-visibility
```

æ³¨å†Œ

```js
import { createApp } from "vue";
import App from "./App.vue";
// å¼•å…¥è¯¥ç¬¬ä¸‰æ–¹åº“
import { ObserveVisibility } from "vue3-observe-visibility";

const app = createApp(App);

// å°†å…¶æ³¨å†Œæˆä¸ºä¸€ä¸ªå…¨å±€çš„æŒ‡ä»¤
app.directive("observe-visibility", ObserveVisibility);

app.mount("#app");
```

ä½¿ç”¨ç¤ºä¾‹

```vue
<template>
    <div>
        <h1>ç¤ºä¾‹</h1>
        <!-- è¯¥å…ƒç´ è¿›å…¥æˆ–è€…ç¦»å¼€è§†å£æ—¶ï¼Œä¼šè§¦å‘å›è°ƒå‡½æ•° -->
        <div
            v-observe-visibility="{
                callback: visibilityChange,
                intersection: {
                    root: null,
                    rootMargin: '0px',
                    threshold: 0,
                }, // é…ç½®å¯¹è±¡
            }"
            class="target"
        ></div>
    </div>
</template>

<script setup>
function visibilityChange(isVisiable) {
    console.log(isVisiable ? "è¿›å…¥è§†å£" : "ç¦»å¼€è§†å£");
}
</script>

<style scoped>
.target {
    height: 200px;
    width: 200px;
    background-color: pink;
    margin: 0 auto;
    margin-top: 1000px;
}
</style>
```

### å®æˆ˜æ¼”ç»ƒ

```js main.js
import { createApp } from "vue";
import App from "./App.vue";
import { ObserveVisibility } from "vue3-observe-visibility";

const app = createApp(App);
// æ³¨å†ŒæŒ‡ä»¤
app.directive("observe-visibility", ObserveVisibility);

app.mount("#app");
```

```vue App.vue
<template>
    <div>
        <h1>å›¾ç‰‡æ‡’åŠ è½½ç¤ºä¾‹</h1>
        <div class="image-grid">
            <!-- ä¸€å®šè¦é…ç½® once é…ç½®é¡¹ -->
            <!-- å¦åˆ™ä¼šåœ¨å¯è§†çŠ¶æ€å‘ç”Ÿå˜åŒ–æ—¶åå¤åŠ è½½ -->
            <img
                v-observe-visibility="{
                    callback: visibilityChanged,
                    once: true, // ç›¸å½“äºåŠ è½½ä¸€æ¬¡ä¹‹åè°ƒç”¨ unobserve
                    intersection: {
                        root: null,
                        rootMargin: '0px',
                        threshold: 0.1,
                    },
                }"
                v-for="(url, index) in imageUrls"
                :key="index"
                :data-src="url"
                :alt="'id ' + (index + 1)"
                :src="loadingImage"
                @error="handleError"
            />
        </div>
    </div>
</template>

<script setup>
import { ref } from "vue";

// ç”Ÿæˆä¸€äº›å›¾ç‰‡URL
const imageUrls = ref([]);
// å¾€ imageUrls ä¸­æ·»åŠ  50 ä¸ªå›¾ç‰‡ URL
for (let i = 1; i <= 50; i++) {
    imageUrls.value.push(`https://picsum.photos/id/${i}/600/400`);
}

// åŠ è½½å›¾ç‰‡çš„ url
const loadingImage =
    "https://dummyimage.com/600x400/cccccc/000000&text=Loading";
// é”™è¯¯å›¾ç‰‡çš„ url
const errorImage = "https://dummyimage.com/600x400/ff0000/ffffff&text=Error";

function visibilityChanged(visibility, entry) {
    const img = entry.target;
    if (visibility) {
        img.src = img.dataset.src;
    }
}

// å›¾ç‰‡åŠ è½½å¤±è´¥æ—¶çš„å¤„ç†å‡½æ•°
function handleError(event) {
    const img = event.target;
    img.src = errorImage;
}
</script>

<style scoped>
.image-grid {
    display: flex;
    flex-wrap: wrap;
    width: 800px;
    margin: 0 auto;
}

.image-grid img {
    display: block;
    margin: 10px;
    width: 200px;
    height: 150px;
    object-fit: cover;
}
</style>
```

---
