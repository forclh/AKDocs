# 如何加载大量图标

[[TOC]]

::: tip 要点速览

- 首选 SVG 雪碧图（`symbol + use`）：一次请求、强缓存、跨页面复用、样式可控。
- 少量或交互复杂图标：用内联 SVG 组件（更易做动画/状态切换）。
- 避免 icon font 作为主方案：不支持多色、可访问性差、失败退化体验差。
- 工程化生成 sprite：自动扫描目录生成 `symbolId`，统一命名、减少维护成本。
- 主题与颜色：使用 `fill="currentColor"`，CSS 控制颜色；为 `symbol` 添加 `<title>`。
  :::

## 快速上手

```svg
<!-- icons-sprite.svg：集中定义所有图标（部署到静态目录或 CDN） -->
<svg xmlns="http://www.w3.org/2000/svg" style="display:none">
  <symbol id="icon-user" viewBox="0 0 24 24"><path fill="currentColor" d="..."/></symbol>
  <symbol id="icon-settings" viewBox="0 0 24 24"><path fill="currentColor" d="..."/></symbol>
</svg>
```

```html
<!-- 页面使用：按需引用指定图标（可缓存、可复用） -->
<svg width="24" height="24" fill="currentColor" role="img" aria-label="用户">
  <use href="/assets/icons-sprite.svg#icon-user"></use>
</svg>

<svg width="32" height="32" style="color:#333" aria-hidden="true">
  <use href="/assets/icons-sprite.svg#icon-settings"></use>
</svg>
```

::: warning 场景选型建议

- 大量、稳定集合：优先外部 SVG 雪碧图（一次请求，强缓存，跨页面复用）。
- 少量或需复杂交互：内联 SVG 组件（动画与交互友好）。
- 老旧项目兜底：icon font 仅作为兜底，不建议作为主方案。
  :::

## 核心问题引入（面试高频题）

> **面试题**：在你的项目中，如果遇到大量图标，你会怎么优化？  
> （常见基础回答：“用 icon font 或直接用 SVG”——虽不算错，但无法体现知识深度，需进一步展开）

## 常见图标方案及优劣势分析

### 内联 SVG

- **实现方式**：将 SVG 代码直接嵌入 HTML 文件中
- **优势**：减少 1 次 HTTP 请求，图标渲染速度快
- **致命缺点**：
  - 大量重复图标会导致 HTML 文件臃肿，增加文件体积；
  - SVG 代码无法被浏览器缓存复用，多页面场景下效率低。

### 图标字体（icon font）

- **实现方式**：将图标封装为字体文件（如.ttf/.woff），通过字体引用方式显示
- **曾经的优势**：过去流行，支持简单的颜色控制（通过`color`属性）
- **核心问题**：
  - 字体文件加载失败时，图标会显示为“方框”（占位异常）；
  - 存在跨域加载问题；
  - 抗锯齿效果差，图标边缘易模糊（尤其低分辨率屏幕）；
  - **不支持多色图标**（无法满足复杂图标需求）；
  - 可访问性差：本质是“文字”，屏幕阅读器无法识别为“图标”，对残障用户不友好。

## 核心方案：SVG 雪碧图

### 核心思想

与传统 CSS 雪碧图逻辑一致：**将多个零散图标合并为 1 个 SVG 文件**，通过 1 次 HTTP 请求加载完成，后续按需调用，兼顾“减少请求”“缓存复用”“易维护”三大需求。

### 核心优势（对比传统方案）

- 减少 HTTP 请求：1 次请求加载所有图标，降低网络开销；
- 支持浏览器缓存：SVG 文件作为外部资源可被缓存，多页面复用效率高；
- 矢量特性：文件体积小（比位图小），且支持无损缩放（适配不同分辨率屏幕）；
- 样式可控性强：可通过 CSS 直接控制颜色（`fill`）、描边（`stroke`）等属性；
- 可访问性友好：支持添加语义化描述，适配屏幕阅读器。

### 基于 `symbol` 的实现步骤（业界推荐）

#### 步骤 1：制作 SVG 雪碧图文件（定义阶段）

创建独立的 SVG 文件（如`icons-sprite.svg`），核心结构如下：

```svg
<!-- 外层SVG：用display:none隐藏（仅作为图标定义容器，不直接显示） -->
<svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
  <!-- 单个图标：用symbol包裹，必须设置唯一id（用于后续引用） -->
  <symbol id="icon-user" viewBox="0 0 24 24">
    <!-- 图标路径（可从设计稿导出） -->
    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm0-14c-2.21 0-4 1.79-4 4h2c0-1.1.9-2 2-2s2 .9 2 2-1.1 2-2 2c-2.21 0-4 1.79-4 4h2c0-1.1.9-2 2-2s2 .9 2 2 1.1 2 2 2 2-1.1 2-2v-2c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2zm0 4c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z"/>
    <!-- 可访问性优化：添加title（屏幕阅读器会读取） -->
    <title>用户图标</title>
  </symbol>

  <!-- 其他图标：重复symbol结构，设置不同id -->
  <symbol id="icon-settings" viewBox="0 0 24 24">
    <path d="M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.58.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.05.3-.09.63-.09.94s.02.64.07.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.58-.24 1.13-.57 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/>
    <title>设置图标</title>
  </symbol>
</svg>
```

#### 步骤 2：在 HTML 中引用图标（使用阶段）

通过`<svg>`+`<use>`标签调用雪碧图中的指定图标，`href`属性指向雪碧图文件路径+图标 id：

```html
<!-- 引用“用户图标”：href=雪碧图路径#图标id -->
<svg width="24" height="24" fill="currentColor">
  <use href="./icons-sprite.svg#icon-user"></use>
</svg>

<!-- 引用“设置图标”：可通过CSS修改颜色、大小 -->
<svg width="32" height="32" style="fill: #333;">
  <use href="./icons-sprite.svg#icon-settings"></use>
</svg>
```

::: info 框架与工程接入（Vite/Webpack）

- Vite：使用 `vite-plugin-svg-icons` 自动扫描 `src/icons` 目录生成 sprite。

```ts
// vite.config.ts
import { defineConfig } from "vite";
import { createSvgIconsPlugin } from "vite-plugin-svg-icons";
import path from "path";

export default defineConfig({
  plugins: [
    createSvgIconsPlugin({
      iconDirs: [path.resolve(process.cwd(), "src/icons")],
      symbolId: "icon-[name]",
    }),
  ],
});
```

```ts
// main.ts：在应用启动时注入生成的 sprite
import "virtual:svg-icons-register";
```

```vue
<template>
  <svg class="icon" aria-hidden="true">
    <use href="#icon-user"></use>
  </svg>
</template>
```

- Webpack：使用 `svg-sprite-loader` 或相关插件生成雪碧图，统一 `symbolId` 规则。
  :::

## 工程化实践：自动生成 SVG 雪碧图

手动制作雪碧图效率低，前端工程化中常用工具自动生成：

- **webpack 生态**：使用`svg-sprite-loader`（loader）或`svg-sprite-plugin`（插件），配置后可自动扫描项目中的 SVG 图标，合并为雪碧图；
- **其他工具**：如`gulp-svg-sprite`（gulp 生态）、在线工具（适合小型项目快速生成）。

## 面试回答建议（体现专业性）

当被问及“大量图标优化方案”时，可按以下逻辑回答：

1. **先破后立**：先说明内联 SVG、icon font 的局限性（点出关键缺点，如 HTML 臃肿、多色不支持）；
2. **核心方案**：提出“SVG 雪碧图”是最优解之一，解释其核心思想（合并资源、一次请求、缓存复用）；
3. **技术细节**：简述基于`symbol`元素的实现步骤（定义雪碧图文件+HTML 中用`use`引用）；
4. **优势延伸**：补充 SVG 雪碧图的矢量特性、样式可控性、可访问性优势；
5. **工程化补充**：提及用 webpack loader 自动生成雪碧图，体现工程化思维。
   ::: danger 常见误区与避坑

- 过度使用 icon font：不支持多色、可访问性差、失败退化体验差；现代项目不建议作为主方案。
- Base64/内联过多图标：导致 HTML/CSS 体积膨胀，缓存复用差；应放入外部资源并走缓存。
- 雪碧图更新频繁：建议按产品线或模块拆分多个 sprite，减少失效范围与缓存抖动。
- 忽视可访问性：未添加 `<title>` 或 `aria-label` 使屏幕阅读器无法识别含义。
- 命名混乱：未统一 `symbolId` 命名规范，后期维护成本高，易冲突。
  :::

## 小结与后续

- 大集合图标选用外部 SVG 雪碧图，配合 CDN 缓存与版本号控制；交互复杂的图标用内联组件。
- 通过工程插件自动生成与注入，统一命名与使用方式，降低维护成本。
- 保持 `currentColor` 主题化与可访问性（`role="img"`、`aria-label`、`<title>`），确保通用性与易用性。
