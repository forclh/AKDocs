# 【反射与代理】偷懒的构造函数 👌

[[TOC]]

::: tip 要点速览

- 使用 `Proxy` 的 `construct` trap，把构造参数自动映射到实例属性。
- 通过 `Reflect.construct(target, args, newTarget)` 保持原型链与继承语义一致。
- 注意只读/不可枚举/重名覆盖等细节，避免破坏不变式与可维护性。
  :::

## 问题动机：重复的构造赋值

```js
class User {
  constructor(firstName, lastName, age) {
    // 下面这三行代码太重复了，有没有什么办法可以优化呢？
    this.firstName = firstName;
    this.lastName = lastName;
    this.age = age;
  }
}

const user = new User("Aiden", "Kao", 18);
```

::: info 思路
与其在构造函数内部逐行赋值，不如通过“构造拦截”在实例创建完成后，统一按约定把参数映射到属性上。
:::

## 核心实现：构造拦截 + 自动赋值

```js
class User {}

function constructorProxy(TargetClass, ...propNames) {
  // 类本质是函数，函数本质是对象，是对象就可以进行 Proxy 代理
  return new Proxy(TargetClass, {
    construct(t, args, newTarget) {
      // 用 Reflect.construct 保持原型与继承语义（第三参很关键）
      const instance = Reflect.construct(t, args, newTarget);
      // 将位置参数映射到实例属性（按 propNames 顺序）
      propNames.forEach((name, i) => {
        Reflect.set(instance, name, args[i]);
      });
      return instance; // 必须返回对象作为构造结果
    },
  });
}

const UserProxy = constructorProxy(User, "firstName", "lastName", "age");
const user = new UserProxy("Aiden", "Kao", 18);
```

::: warning 注意

- 始终通过 `Reflect.construct` 创建实例，确保继承/原型链正确（尤其是有子类时）。
- 赋值使用 `Reflect.set` 更一致；必要时可判断属性是否存在或是否可写。
- `construct` 必须返回一个对象；返回原始值会抛错或语义不一致。
  :::

## 与在构造函数中直接赋值的对比

```js
// 直接在构造函数中赋值：读者需在每个类中重复写样板代码
class User {
  constructor(firstName, lastName, age) {
    this.firstName = firstName;
    this.lastName = lastName;
    this.age = age;
  }
}

// Proxy 构造拦截：赋值逻辑抽离，统一可复用，便于加入校验/默认值
class User {}
const UserProxy = constructorProxy(User, "firstName", "lastName", "age");
```

::: info 对比结论

- 直接赋值简单直观，但样板重复且扩展能力受限。
- 构造拦截将“赋值策略”外置，可复用且易于统一规范（例如校验、默认值、只读控制等）。
  :::

## 常见坑位

::: danger 易踩坑

- 忘记使用 `Reflect.construct` 的第三个参数 `newTarget`，会破坏继承/原型链语义。
- 未返回对象或返回原始值，导致构造调用不符合规范或抛错。
- 对只读/不可配置属性强制赋值，可能违反对象不变式（应先检查描述符）。
- 属性名与类内部字段/访问器重名，带来覆盖与副作用；需明确约定与测试。
- 在大批量对象上进行深度赋值可能带来性能问题；必要时懒赋值或分批处理。
  :::

## 使用建议

- 小型场景可保持构造内赋值；样板重复明显时引入构造拦截并外置策略。
- 一律通过 `Reflect` 执行真实操作（`construct`/`set`），确保语义与不变式。

## 小结

1. `Proxy` 的 `construct` 能把“构造样板”外置，统一拦截实现自动赋值。
2. `Reflect.construct` 保持继承与原型语义一致；配合 `Reflect.set` 更稳健。
