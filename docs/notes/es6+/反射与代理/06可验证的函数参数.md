# 【反射与代理】可验证的函数参数 👌

[[TOC]]

::: tip 要点速览

- 使用 `Proxy` 的 `apply` trap 在函数调用前进行参数校验/转换/默认值填充。
- 始终使用 `Reflect.apply(func, thisArg, args)` 执行真实调用，保持 `this` 与返回值语义。
- 支持两类形态：按位置的类型数组校验、按键的对象参数校验（更可读）。
- 对异步函数同样适用；构造调用需使用 `construct` 进行拦截与校验。
  :::

## 基础示例：按位置的类型校验

```js
// 示例函数
function sum(a, b) {
  return a + b;
}

// 创建一个带类型校验的函数代理：types 为期望的 typeof 类型字符串
function validateFunc(func, ...types) {
  return new Proxy(func, {
    apply(target, thisArg, args) {
      types.forEach((type, index) => {
        if (typeof args[index] !== type) {
          throw new TypeError(
            `第 ${index + 1} 个参数 ${args[index]} 不满足类型 ${type}`
          );
        }
      });
      return Reflect.apply(target, thisArg, args);
    },
  });
}

const sumProxy = validateFunc(sum, "number", "number");
console.log(sumProxy(1, 2)); // 3
// console.log(sumProxy("1", 2)); // 会抛出类型错误
```

::: warning 注意

- `apply` 必须返回函数执行的结果；不要返回布尔值，否则会破坏语义。
- 直接使用 `typeof` 判断数组会得到 `"object"`；对数组/日期/正则需更精细的判断。
  :::

## 进阶：对象参数校验（更可读）

```js
// 约定使用对象参数：{ a: 1, b: 2 }
function sumObj({ a, b }) {
  return a + b;
}

function validateBySchema(func, schema) {
  // schema: { key: { type, required, default, validate, transform } }
  return new Proxy(func, {
    apply(target, thisArg, args) {
      if (args.length !== 1 || typeof args[0] !== "object") {
        throw new TypeError("该函数约定使用单个对象参数进行调用");
      }
      const input = { ...args[0] };

      for (const key of Object.keys(schema)) {
        const rule = schema[key];
        let val = input[key];

        if (val === undefined) {
          if (rule.required) {
            throw new TypeError(`缺少必需参数：${key}`);
          }
          if ("default" in rule) val = rule.default;
        }

        if (val !== undefined) {
          if (rule.type) {
            const isTypeOk =
              rule.type === "array"
                ? Array.isArray(val)
                : typeof val === rule.type;
            if (!isTypeOk)
              throw new TypeError(`参数 ${key} 类型不满足 ${rule.type}`);
          }
          if (rule.validate && !rule.validate(val)) {
            throw new TypeError(`参数 ${key} 未通过自定义校验`);
          }
          if (rule.transform) {
            val = rule.transform(val);
          }
          input[key] = val;
        }
      }

      // 使用加工后的 input 调用原函数
      return Reflect.apply(target, thisArg, [input]);
    },
  });
}

const schema = {
  a: { type: "number", required: true },
  b: { type: "number", default: 0, validate: (v) => v >= 0 },
};
const sumObjProxy = validateBySchema(sumObj, schema);
console.log(sumObjProxy({ a: 1, b: 2 })); // 3
console.log(sumObjProxy({ a: 1 })); // 1（默认 b = 0）
// console.log(sumObjProxy({ a: 1, b: -1 })); // 自定义校验不通过
```

::: info 扩展点

- `transform` 可用于预处理（如字符串转数字、去空格、格式化）。
- `validate` 可承载复杂业务规则（范围、集合、唯一性等）。
- 可为不同函数共享同一套 `schema`，提升一致性与复用性。
  :::

## 构造调用的参数校验（`construct`）

```js
// 对构造函数进行参数校验
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
}

function validateCtor(Ctor, ...types) {
  return new Proxy(Ctor, {
    construct(t, args, newTarget) {
      types.forEach((type, i) => {
        if (typeof args[i] !== type) {
          throw new TypeError(`第 ${i + 1} 个构造参数类型不满足 ${type}`);
        }
      });
      return Reflect.construct(t, args, newTarget);
    },
  });
}

const SafePoint = validateCtor(Point, "number", "number");
const p = new SafePoint(1, 2);
```

## 常见坑位

::: danger 易踩坑

- 未使用 `Reflect.apply/construct`，导致 `this` 绑定或原型链不正确。
- 仅用 `typeof` 判断数组/日期等复杂类型，结果为 `object`，产生误判。
- 忽略多余或缺失参数处理，导致函数内部出现 `undefined` 异常。
- 在代理中改变 `args` 的结构却未同步更新校验逻辑，产生偏差。
- 在高频函数上进行复杂校验，可能带来性能问题；需要做缓存或降级。
  :::

## 使用建议

- 参数较少且简单时使用位置类型数组；复杂业务优先对象参数 + `schema`。
- 统一在 `apply/construct` 内进行校验，并通过 `Reflect` 执行真实调用。
- 对异步函数同样适用；校验应尽量同步完成，避免引入竞争条件。
- 为常用校验提炼工具库（类型判断、转换、范围校验），提升复用与一致性。

## 小结

1. 通过 `Proxy` 的 `apply/construct` 能在函数/构造调用前实现统一的参数校验层。
2. `Reflect.apply/construct` 保证调用语义正确；对象参数 + `schema` 更适合复杂场景。
3. 注意类型判断的边界、性能与副作用控制，确保校验既准确又可维护。
